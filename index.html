<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Генератор ANSI‑блоков для Discord</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #editor span { font-style: italic; }
    #bold { font-weight: bold; }
    #underline { text-decoration: underline; }
    .toast { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: #fff; padding: .5rem 1rem; border-radius: .5rem; opacity: 0; transition: opacity .3s; pointer-events: none; }
    .toast.show { opacity: 1; }
    pre { white-space: pre-wrap; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">
  <h1 class="text-2xl font-bold mb-4 text-center">Генератор ANSI‑блоков для Discord</h1>
  <div class="max-w-6xl mx-auto">
    <div id="editor" contenteditable class="border border-gray-300 rounded-lg p-4 bg-white min-h-[500px] whitespace-pre-wrap"></div>
  </div>
  <div class="fixed top-24 right-4 w-60 bg-white p-4 rounded-lg shadow-lg">
    <button id="copy" class="w-full bg-green-600 text-white py-2 rounded-lg mb-2">Скопировать в Discord</button>
    <button id="clear-format" class="w-full bg-red-500 text-white py-2 rounded-lg mb-4">Очистить форматирование</button>
    <div class="mb-2 font-semibold">Цвет текста</div>
    <div id="fg-palette" class="grid grid-cols-4 gap-1 mb-4"></div>
    <div class="mb-2 font-semibold">Цвет фона</div>
    <div id="bg-palette" class="grid grid-cols-4 gap-1 mb-4"></div>
    <div class="mb-2 font-semibold">Стили</div>
    <div class="flex gap-2">
      <button id="bold" title="Жирный" class="flex-1 border border-gray-400 rounded-lg py-1">B</button>
      <button id="underline" title="Подчёркнутый" class="flex-1 border border-gray-400 rounded-lg py-1">U</button>
    </div>
  </div>
  <div id="toast" class="toast">Скопировано!</div>
<script>
  const ESC = '\u001b';
  const colors = [30,31,32,33,34,35,36,37];
  const paletteColors = ['gray','red','green','yellow','blue','magenta','cyan','white'];

  function makePalette(containerId, isBg) {
    const cont = document.getElementById(containerId);
    colors.forEach((code,i) => {
      const btn = document.createElement('button');
      btn.className = 'w-8 h-8 rounded-lg border border-gray-300';
      btn.style.backgroundColor = paletteColors[i];
      btn.title = '[' + (isBg ? '0;' + (code+10) : '0;' + code) + 'm';
      btn.addEventListener('click', () => {
        console.log('[Palette click]', containerId, code);
        applyToSelection(spans => {
          console.log('[Spans before apply]', spans);
          spans.forEach(span => {
            const dataAttr = isBg ? 'bg' : 'fg';
            if (span.dataset[dataAttr] == code) {
              console.log('Removing', dataAttr, 'from', span.textContent);
              delete span.dataset[dataAttr];
              span.style[dataAttr === 'fg' ? 'color' : 'backgroundColor'] = '';
            } else {
              console.log('Setting', dataAttr, 'to', code, 'on', span.textContent);
              span.dataset[dataAttr] = code;
              span.style[dataAttr === 'fg' ? 'color' : 'backgroundColor'] = paletteColors[i];
            }
          });
        });
      });
      cont.appendChild(btn);
    });
  }

  makePalette('fg-palette', false);
  makePalette('bg-palette', true);

  function applyToSelection(callback) {
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    console.log('[Selection]', sel.toString());
    const contents = range.cloneContents();
    const wrapper = document.createElement('span');
    wrapper.appendChild(contents);
    range.deleteContents();
    range.insertNode(wrapper);
    const spans = Array.from(wrapper.querySelectorAll('span'));
    if (!spans.length) spans.push(wrapper);
    console.log('[wrapper spans]', spans);
    callback(spans);
    // unwrap
    const parent = wrapper.parentNode;
    while (wrapper.firstChild) parent.insertBefore(wrapper.firstChild, wrapper);
    parent.removeChild(wrapper);
    sel.removeAllRanges();
  }

  document.getElementById('bold').addEventListener('click', () => {
    console.log('[Style click]', 'bold');
    applyToSelection(spans => {
      spans.forEach(span => {
        if (span.dataset.bold) {
          console.log('Removing bold from', span.textContent);
          delete span.dataset.bold;
          span.style.fontWeight = '';
        } else {
          console.log('Adding bold to', span.textContent);
          span.dataset.bold = 1;
          span.style.fontWeight = 'bold';
          delete span.dataset.underline;
          span.style.textDecoration = '';
        }
      });
    });
  });

  document.getElementById('underline').addEventListener('click', () => {
    console.log('[Style click]', 'underline');
    applyToSelection(spans => {
      spans.forEach(span => {
        if (span.dataset.underline) {
          console.log('Removing underline from', span.textContent);
          delete span.dataset.underline;
          span.style.textDecoration = '';
        } else {
          console.log('Adding underline to', span.textContent);
          span.dataset.underline = 4;
          span.style.textDecoration = 'underline';
          delete span.dataset.bold;
          span.style.fontWeight = '';
        }
      });
    });
  });

  document.getElementById('clear-format').addEventListener('click', () => {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    console.log('[Clear format] Selection:', sel.toString());
    const text = range.toString();
    range.deleteContents();
    range.insertNode(document.createTextNode(text));
    sel.removeAllRanges();
  });

  function generate(root) {
    let out = '';
    const open = codes => out += '```ansi\n' + ESC + '[' + codes.join(';') + 'm';
    const close = () => out += ESC + '[0m\n```';
    (function walk(n) {
      if (n.nodeType === 3) { out += n.textContent; return; }
      if (n.nodeType !== 1) return;
      if (n.tagName === 'BR') { out += '\n'; return; }
      if (n.tagName === 'SPAN') {
        const codes = [];
        if (n.dataset.bold) codes.push('1');
        if (n.dataset.underline) codes.push('4');
        if (n.dataset.fg) codes.push(n.dataset.fg);
        if (n.dataset.bg) codes.push((parseInt(n.dataset.bg) + 10).toString());
        console.log('[Generate span]', n.textContent, codes);
        if (codes.length) { open(codes); Array.from(n.childNodes).forEach(walk); close(); return; }
      }
      Array.from(n.childNodes).forEach(walk);
    })(root);
    return out;
  }

  document.getElementById('copy').addEventListener('click', () => {
    const text = generate(document.getElementById('editor'));
    console.log('[Generated text]', text);
    navigator.clipboard.writeText(text).then(() => {
      const t = document.getElementById('toast');
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 1200);
    });
  });
</script>
</body>
</html>
