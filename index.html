<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Генератор ANSI‑блоков для Discord</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #editor span { font-style: italic; }
    #bold { font-weight: bold; }
    #underline { text-decoration: underline; }
    .toast { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: #fff; padding: .5rem 1rem; border-radius: .5rem; opacity: 0; transition: opacity .3s; pointer-events: none; }
    .toast.show { opacity: 1; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">
  <h1 class="text-2xl font-bold mb-4 text-center">Генератор ANSI‑блоков для Discord</h1>
  <div class="max-w-6xl mx-auto">
    <div id="editor" contenteditable="true" class="border border-gray-300 rounded-lg p-4 bg-white min-h-[500px] whitespace-pre-wrap"></div>
  </div>

  <div class="fixed top-24 right-4 w-60 bg-white p-4 rounded-lg shadow-lg">
    <button id="copy" class="w-full bg-green-600 text-white py-2 rounded-lg mb-2">Скопировать в Discord</button>
    <button id="clear-format" class="w-full bg-red-500 text-white py-2 rounded-lg mb-4">Очистить форматирование</button>
    <div class="mb-2 font-semibold">Цвет текста</div>
    <div id="fg-palette" class="grid grid-cols-4 gap-1 mb-4"></div>
    <div class="mb-2 font-semibold">Цвет фона</div>
    <div id="bg-palette" class="grid grid-cols-4 gap-1 mb-4"></div>
    <div class="mb-2 font-semibold">Стили</div>
    <div class="flex gap-2">
      <button id="bold" title="Жирный" class="flex-1 border border-gray-400 rounded-lg py-1">B</button>
      <button id="underline" title="Подчёркнутый" class="flex-1 border border-gray-400 rounded-lg py-1">U</button>
    </div>
  </div>

  <div id="toast" class="toast">Скопировано!</div>

<script>
  const ESC = '\u001b';
  const colors = [30,31,32,33,34,35,36,37];
  const paletteColors = ['gray','red','green','yellow','blue','magenta','cyan','white'];

  function makePalette(containerId, isBg) {
    const cont = document.getElementById(containerId);
    colors.forEach((code, i) => {
      const btn = document.createElement('button');
      btn.className = 'w-8 h-8 rounded-lg border border-gray-300';
      btn.style.backgroundColor = paletteColors[i];
      btn.title = '[' + '0;' + code + (isBg?';40m':';0m');
      btn.onclick = () => wrapFormat(isBg?'bg': 'fg', code);
      cont.appendChild(btn);
    });
  }
  makePalette('fg-palette', false);
  makePalette('bg-palette', true);

  function wrapFormat(type, code) {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0).cloneRange();
    // if selection inside span, update that span
    let span = sel.anchorNode.parentElement;
    if (span.tagName!=='SPAN' || span.id==='editor') {
      span = document.createElement('span');
      range.surroundContents(span);
    }
    // toggle or set
    if (type==='fg') {
      if (span.dataset.fg==code) delete span.dataset.fg;
      else span.dataset.fg = code;
      span.style.color = span.dataset.fg?paletteColors[colors.indexOf(parseInt(span.dataset.fg))]:null;
    } else if (type==='bg') {
      if (span.dataset.bg==code) delete span.dataset.bg;
      else span.dataset.bg = code;
      span.style.backgroundColor = span.dataset.bg?paletteColors[colors.indexOf(parseInt(span.dataset.bg))]:null;
    }
    sel.removeAllRanges();
  }

  // стили
  document.getElementById('bold').onclick = () => toggleStyle('bold');
  document.getElementById('underline').onclick = () => toggleStyle('underline');
  function toggleStyle(style) {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0).cloneRange();
    let span = sel.anchorNode.parentElement;
    if (span.tagName!=='SPAN' || span.id==='editor') {
      span = document.createElement('span');
      range.surroundContents(span);
    }
    if (style==='bold') {
      if (span.dataset.bold) { delete span.dataset.bold; span.style.fontWeight=null; }
      else { span.dataset.bold=1; span.style.fontWeight='bold'; }
    } else if (style==='underline') {
      if (span.dataset.underline) { delete span.dataset.underline; span.style.textDecoration=null; }
      else { span.dataset.underline=4; span.style.textDecoration='underline'; }
    }
    sel.removeAllRanges();
  }

  document.getElementById('clear-format').onclick = () => {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const text = range.toString();
    range.deleteContents();
    range.insertNode(document.createTextNode(text));
    sel.removeAllRanges();
  };

  // генерация
  function generate(root) {
    let out = '';
    const open = codes => out += '```ansi\n' + ESC+'['+codes.join(';')+'m';
    const close = () => out += ESC+'[0m\n```';
    function walk(node) {
      if (node.nodeType===3) { out+=node.textContent; return; }
      if (node.nodeType!==1) return;
      if (node.tagName==='BR') { out+='\n'; return; }
      if (node.tagName==='SPAN') {
        const codes=[];
        if (node.dataset.bold) codes.push('1');
        if (node.dataset.underline) codes.push('4');
        if (node.dataset.fg) codes.push(node.dataset.fg);
        if (node.dataset.bg) codes.push((parseInt(node.dataset.bg)+10).toString());
        if (codes.length) { open(codes); node.childNodes.forEach(walk); close(); return; }
      }
      node.childNodes.forEach(walk);
    }
    root.childNodes.forEach(walk);
    return out;
  }

  document.getElementById('copy').onclick = () => {
    const text = generate(document.getElementById('editor'));
    navigator.clipboard.writeText(text).then(()=>{
      const t=document.getElementById('toast'); t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200);
    });
  };
</script>
</body>
</html>
