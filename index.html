<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Генератор ANSI‑блоков для Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: sans-serif; background: #1f2030; color: #dcddde; }
    #editor { width:100%; max-width:800px; min-height:200px; margin:2rem auto; padding:1rem; background:#2f3136; border:1px solid #2f3136; border-radius:.5rem; white-space: pre-wrap; color: #dcddde; }
    .toolbar { position:fixed; top:1rem; right:1rem; width:260px; background:#2f3136; padding:1rem; border:1px solid #36393f; border-radius:.5rem; }
    .toolbar button { width:100%; margin-bottom:.5rem; padding:.5rem; border:1px solid #40444b; border-radius:.25rem; cursor:pointer; background:#36393f; color:#dcddde; }
    .toolbar .palette { display:grid; grid-template-columns:repeat(4,1fr); gap:.25rem; margin-bottom:.5rem; }
    #bg-palette { grid-template-columns: repeat(8, 1fr); }
    .palette button { width:100%; height:1.5rem; border:1px solid #40444b; padding:0; }
    #bold, #underline { background:#36393f; }
    #toast { position:fixed; bottom:1rem; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#fff; padding:.5rem 1rem; border-radius:.5rem; opacity:0; transition:opacity .3s; }
    #toast.show { opacity:1; }
  </style>
</head>
<body>
  <h1 style="text-align:center; margin-top:1rem;">Генератор ANSI‑блоков для Discord</h1>
  <div id="editor" contenteditable spellcheck="false"></div>
  <div class="toolbar">
    <button id="copy">Скопировать в Discord</button>
    <button id="clear">Очистить форматирование</button>
    <div style="font-weight:bold; margin-top:1rem;">Цвет текста</div>
    <div id="fg-palette" class="palette"></div>
    <div style="font-weight:bold; margin-top:1rem;">Цвет фона</div>
    <div id="bg-palette" class="palette"></div>
    <div style="font-weight:bold; margin-top:.5rem;">Стили</div>
    <button id="bold">B</button>
    <button id="underline">U</button>
  </div>
  <div id="toast">Скопировано!</div>
<script>
  console.log('ANSI Discord Generator script loaded');
  const ESC = '\u001b';
  const bgCss = ['#002b36','#cb4b16','#586e75','#657b83','#839496','#6c71c4','#93a1a1','#fdf6e3'];
  const fgCss = ['#586e75','#dc322f','#859900','#b58900','#268bd2','#d33682','#2aa198','#eee8d5'];
  const fgCodes = [30,31,32,33,34,35,36,37];
  const bgCodes = fgCodes.map(c => c + 10);

  function wrap(type, value) {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    span.dataset[type] = value;
    if (type === 'fg') span.style.color = fgCss[fgCodes.indexOf(+value)];
    if (type === 'bg') span.style.backgroundColor = bgCss[bgCodes.indexOf(+value)];
    if (type === 'bold') span.style.fontWeight = 'bold';
    if (type === 'underline') span.style.textDecoration = 'underline';
    span.appendChild(range.extractContents());
    range.insertNode(span);
    sel.removeAllRanges();
  }

  const fgCont = document.getElementById('fg-palette');
  const bgCont = document.getElementById('bg-palette');
  fgCss.forEach((color,i) => {
    const btn = document.createElement('button'); btn.style.background = color;
    btn.addEventListener('click', e => { e.preventDefault(); wrap('fg', fgCodes[i]); });
    fgCont.appendChild(btn);
  });
  bgCss.forEach((color,i) => {
    const btn = document.createElement('button'); btn.style.background = color;
    btn.addEventListener('click', e => { e.preventDefault(); wrap('bg', bgCodes[i]); });
    bgCont.appendChild(btn);
  });

  const btnBold = document.getElementById('bold');
  const btnUnder = document.getElementById('underline');
  [btnBold, btnUnder].forEach(btn => btn.addEventListener('mousedown', e => e.preventDefault()));
  btnBold.addEventListener('click', e => { e.preventDefault(); wrap('bold',1); });
  btnUnder.addEventListener('click', e => { e.preventDefault(); wrap('underline',4); });

  document.getElementById('clear').addEventListener('click', () => {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const frag = range.extractContents();
    const cleanFrag = document.createDocumentFragment();
    const cleanNode = node => {
      if (node.nodeType===1 && node.tagName==='SPAN') node.childNodes.forEach(cleanNode);
      else cleanFrag.appendChild(node.cloneNode(true));
    };
    frag.childNodes.forEach(cleanNode);
    range.insertNode(cleanFrag);
    sel.removeAllRanges();
  });

  function generateANSI(root) {
  console.log('--- generateANSI start ---');
  const paras = [];
  let cur = [];
  Array.from(root.childNodes).forEach(n => {
    console.log('Node:', n, 'type:', n.nodeType, 'tag:', n.tagName);
    if (n.nodeType === 1 && n.tagName === 'DIV') {
      // push previous if exists
      if (cur.length) {
        console.log('Push paragraph before DIV, count:', cur.length);
        paras.push(cur);
        cur = [];
      }
      // this DIV is its own paragraph
      const divChildren = Array.from(n.childNodes);
      console.log('Push DIV paragraph, children count:', divChildren.length);
      paras.push(divChildren);
    } else if (n.nodeType === 1 && n.tagName === 'BR') {
      console.log('Push paragraph at BR, count:', cur.length);
      paras.push(cur);
      cur = [];
    } else {
      cur.push(n);
    }
  });
  if (cur.length) {
    console.log('Push final paragraph, count:', cur.length);
    paras.push(cur);
  }

  let out = '';
  paras.forEach((nodes, pi) => {
    console.log('Paragraph', pi, 'nodes count:', nodes.length);
    const chars = [];
    const recurse = (node, fmt) => {
      const f = { ...fmt };
      if (node.nodeType === 1 && node.tagName === 'SPAN') {
        if (node.dataset.bold) f.bold = true;
        if (node.dataset.underline) f.underline = true;
        if (node.dataset.fg) f.fg = +node.dataset.fg;
        if (node.dataset.bg) f.bg = +node.dataset.bg;
      }
      if (node.nodeType === 3) {
        node.textContent.split('').forEach(ch => chars.push({ ch, fmt: { ...f } }));
      } else if (node.nodeType === 1) {
        if (node.tagName === 'BR') {
          chars.push({ ch: '
', fmt: {} });
        } else {
          Array.from(node.childNodes).forEach(c => recurse(c, f));
        }
      }
    };
    nodes.forEach(n => recurse(n, {}));

    const hasColor = chars.some(c => c.fmt.fg != null || c.fmt.bg != null);
    console.log('Paragraph', pi, 'hasColor:', hasColor, 'chars count:', chars.length);
    if (hasColor) {
      out += '```ansi
';
      let prevCodes = '';
      chars.forEach((item, ci) => {
        const { ch, fmt } = item;
        if (ch !== '\n') {
          const codes = [];
          if (fmt.bold) codes.push(1);
          if (fmt.underline) codes.push(4);
          if (fmt.fg != null) codes.push(fmt.fg);
          if (fmt.bg != null) codes.push(fmt.bg);
          else codes.push(49);
          const codeStr = codes.join(';');
          if (codeStr !== prevCodes) {
            out += ESC + '[' + codeStr + 'm';
            prevCodes = codeStr;
            console.log('Apply codes at char', ci, ':', codeStr);
          }
        } else {
          console.log('Newline in chars at', ci);
        }
        out += ch;
      });
      out += ESC + '[0m\n```\n';
    } else {
      let line = '';
      chars.forEach(item => {
        if (item.fmt.bold && item.ch.trim()) {
          line += '**' + item.ch + '**';
        } else {
          line += item.ch;
        }
      });
      out += line + '\n';
    }
  });
  console.log('--- generateANSI end ---');
  return out;
}

document.getElementById('copy').addEventListener('click',e=>{.addEventListener('click',e=>{
    e.preventDefault();
    const txt=generateANSI(document.getElementById('editor'));
    navigator.clipboard.writeText(txt).then(()=>{
      const t=document.getElementById('toast'); t.classList.add('show');
      setTimeout(()=>t.classList.remove('show'),1500);
    });
  });
</script>
</body>
</html>
