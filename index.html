<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Генератор ANSI‑блоков для Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #1f2030;
      color: #dcddde;
    }
    #editor {
      width: 100%;
      max-width: 800px;
      min-height: 200px;
      margin: 2rem auto;
      padding: 1rem;
      background: #2f3136;
      color: #dcddde;
      border: 1px solid #36393f;
      border-radius: .5rem;
      white-space: pre-wrap;
    }
    .toolbar {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: 260px;
      background: #2f3136;
      color: #dcddde;
      padding: 1rem;
      border: 1px solid #36393f;
      border-radius: .5rem;
    }
    .toolbar button {
      width: 100%;
      margin-bottom: .5rem;
      padding: .5rem;
      cursor: pointer;
      background: #36393f;
      color: #dcddde;
      border: 1px solid #202225;
      border-radius: .25rem;
    }
    .toolbar .palette {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: .25rem;
      margin-bottom: .5rem;
    }
    #bg-palette {
      grid-template-columns: repeat(8, 1fr);
    }
    .palette button {
      width: 100%;
      height: 1.5rem;
      border: 1px solid #36393f;
      padding: 0;
    }
    #bold { font-weight: bold; }
    #underline { text-decoration: underline; }
    #toast {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: .5rem 1rem;
      border-radius: .5rem;
      opacity: 0;
      transition: opacity .3s;
    }
    #toast.show { opacity: 1; }
  </style>
</head>
<body>
  <h1 style="text-align:center; margin-top:1rem;">Генератор ANSI‑блоков для Discord</h1>
  <div id="editor" contenteditable spellcheck="false"></div>
  <div class="toolbar">
    <button id="copy">Скопировать в Discord</button>
    <button id="clear">Очистить форматирование</button>

    <div style="font-weight:bold; margin-top:1rem;">Цвет текста</div>
    <div id="fg-palette" class="palette"></div>

    <div style="font-weight:bold; margin-top:1rem;">Цвет фона</div>
    <div id="bg-palette" class="palette"></div>

    <div style="font-weight:bold; margin-top:.5rem;">Стили</div>
    <button id="bold">B</button>
    <button id="underline">U</button>
  </div>
  <div id="toast">Скопировано!</div>

  <script>
    const ESC       = '\u001b';
    const NEW_LINE  = '\n';

    // Палитры: Solarized Dark + точные фоновые из Discord
    const fgCss   = ['#586e75','#dc322f','#859900','#b58900','#268bd2','#d33682','#2aa198','#eee8d5'];
    const bgCss   = ['#002b36','#cb4b16','#586e75','#657b83','#839496','#6c71c4','#93a1a1','#fdf6e3'];
    const fgCodes = [30,31,32,33,34,35,36,37];
    const bgCodes = fgCodes.map(c=>c+10);

    // ——— Wrap selection in <span> ———
    function wrap(type, value) {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const span  = document.createElement('span');
      span.dataset[type] = value;
      if (type==='fg')        span.style.color           = fgCss[fgCodes.indexOf(+value)];
      if (type==='bg')        span.style.backgroundColor = bgCss[bgCodes.indexOf(+value)];
      if (type==='bold')      span.style.fontWeight      = 'bold';
      if (type==='underline') span.style.textDecoration = 'underline';
      span.appendChild(range.extractContents());
      range.insertNode(span);
      sel.removeAllRanges();
      console.log('wrap:', type, value);
    }

    // ——— Draw palettes ———
    const fgCont = document.getElementById('fg-palette');
    const bgCont = document.getElementById('bg-palette');
    fgCodes.forEach((c,i)=>{
      const btn = document.createElement('button');
      btn.style.background = fgCss[i];
      btn.addEventListener('click', e=>{
        e.preventDefault();
        wrap('fg', c);
      });
      fgCont.appendChild(btn);
    });
    bgCodes.forEach((c,i)=>{
      const btn = document.createElement('button');
      btn.style.background = bgCss[i];
      btn.addEventListener('click', e=>{
        e.preventDefault();
        wrap('bg', c);
      });
      bgCont.appendChild(btn);
    });

    // ——— Bold/Underline ———
    const btnBold      = document.getElementById('bold');
    const btnUnderline = document.getElementById('underline');
    [btnBold, btnUnderline].forEach(btn=>{
      btn.addEventListener('mousedown', e=> e.preventDefault());
    });
    btnBold.addEventListener('click',      e=>{ e.preventDefault(); wrap('bold', 1); });
    btnUnderline.addEventListener('click', e=>{ e.preventDefault(); wrap('underline', 4); });

    // ——— Clear formatting ———
    const clearBtn = document.getElementById('clear');
    clearBtn.addEventListener('mousedown', e=>{
      e.preventDefault();
      console.log('clear: mousedown — selection kept');
    });
    clearBtn.addEventListener('click', e=>{
      e.preventDefault();
      console.log('clear: click — start clearing');
      const sel = window.getSelection();
      if (!sel.rangeCount) {
        console.warn('clear: no selection');
        return;
      }
      const range = sel.getRangeAt(0);
      console.log('clear: range', range);
      const frag = range.extractContents();
      const cleanFrag = document.createDocumentFragment();
      function clean(node) {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN') {
          console.log('clear: unwrap span', node.dataset);
          Array.from(node.childNodes).forEach(clean);
        } else {
          cleanFrag.appendChild(node.cloneNode(true));
        }
      }
      Array.from(frag.childNodes).forEach(clean);
      range.insertNode(cleanFrag);

      // Normalize and remove any empty spans left behind
      const editor = document.getElementById('editor');
      editor.normalize();
      editor.querySelectorAll('span').forEach(span=>{
        if (!span.hasChildNodes()) {
          console.log('clear: removing empty span');
          span.remove();
        }
      });

      sel.removeAllRanges();
      console.log('clear: done');
    });

    // ——— Generate ANSI ———
    function generateANSI(root) {
      console.log('generateANSI: start');
      // split into paragraphs by DIV and BR
      const paras = [];
      let cur = [];
      root.childNodes.forEach(n => {
        if (n.nodeType === 1 && (n.tagName === 'BR' || n.tagName === 'DIV')) {
          paras.push(cur);
          cur = [];
          if (n.tagName === 'DIV' && n.childNodes.length) {
            Array.from(n.childNodes).forEach(c => cur.push(c));
          }
        } else {
          cur.push(n);
        }
      });
      if (cur.length) paras.push(cur);
      console.log('generateANSI: paragraphs =', paras.length);

      const ESCsq = ESC;
      const paraLines = paras.map((nodes, idx) => {
        console.log('generateANSI: build para', idx);
        const chars = [];
        function rec(node, fmt) {
          const f = {...fmt};
          if (node.nodeType === 1 && node.tagName === 'SPAN') {
            if (node.dataset.bold)      f.bold      = true;
            if (node.dataset.underline) f.underline = true;
            if (node.dataset.fg)        f.fg        = +node.dataset.fg;
            if (node.dataset.bg)        f.bg        = +node.dataset.bg;
          }
          if (node.nodeType === 3) {
            node.textContent.split('').forEach(ch => chars.push({ch, fmt:{...f}}));
          } else if (node.nodeType === 1) {
            if (node.tagName === 'BR') {
              chars.push({ch: NEW_LINE, fmt:{}});
            } else {
              node.childNodes.forEach(c => rec(c, f));
            }
          }
        }
        nodes.forEach(n => rec(n, {}));

        let line = '';
        let prev = {bold:false, underline:false, fg:null, bg:null};
        chars.forEach(item => {
          const f = item.fmt;
          if (item.ch !== ' ' && item.ch !== NEW_LINE &&
              (f.bold      !== prev.bold ||
               f.underline !== prev.underline ||
               f.fg        !== prev.fg ||
               f.bg        !== prev.bg)) {
            const codes = [];
            if (f.bold)      codes.push(1);
            if (f.underline) codes.push(4);
            codes.push(f.fg != null ? f.fg : 39);
            codes.push(f.bg != null ? f.bg : 49);
            const cs = ESCsq + '[' + codes.join(';') + 'm';
            console.log('generateANSI: code', cs);
            line += cs;
            prev = {bold:!!f.bold, underline:!!f.underline, fg:f.fg, bg:f.bg};
          }
          line += item.ch;
        });
        return line;
      });

      const anyColor = paraLines.some(l => l.includes(ESCsq + '['));
      let out = '';
      if (anyColor) {
        out += '```ansi' + NEW_LINE;
        paraLines.forEach(l => out += l + NEW_LINE);
        out += ESCsq + '[0m' + NEW_LINE + '```' + NEW_LINE;
      } else {
        paraLines.forEach(l => out += l + NEW_LINE);
      }
      console.log('generateANSI: done, length', out.length);
      return out;
    }

    // ——— Copy to clipboard ———
    const btnCopy = document.getElementById('copy');
    btnCopy.addEventListener('mousedown', e=> e.preventDefault());
    btnCopy.addEventListener('click', e=>{
      e.preventDefault();
      console.log('Copy to clipboard');
      const txt = generateANSI(document.getElementById('editor'));
      navigator.clipboard.writeText(txt).then(()=>{
        console.log('Copy successful');
        const t = document.getElementById('toast');
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), 1500);
      });
    });
  </script>
</body>
</html>
