<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Генератор ANSI‑блоков для Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: sans-serif; background: #f3f4f6; }
    #editor { width:100%; max-width:800px; min-height:200px; margin:2rem auto; padding:1rem; background:#fff; border:1px solid #ddd; border-radius:.5rem; white-space: pre-wrap; }
    .toolbar { position:fixed; top:1rem; right:1rem; width:220px; background:#fff; padding:1rem; border:1px solid #ddd; border-radius:.5rem; }
    .toolbar button { width:100%; margin-bottom:.5rem; padding:.5rem; border:1px solid #ccc; border-radius:.25rem; cursor:pointer; background:#fafafa; }
    .toolbar .palette { display:grid; grid-template-columns:repeat(4,1fr); gap:.25rem; margin-bottom:.5rem; }
    .palette button { width:100%; height:1.5rem; border:1px solid #ccc; padding:0; }
    #bold { font-weight:bold; }
    #underline { text-decoration:underline; }
    #toast { position:fixed; bottom:1rem; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#fff; padding:.5rem 1rem; border-radius:.5rem; opacity:0; transition:opacity .3s; }
    #toast.show { opacity:1; }
  </style>
</head>
<body>
  <h1 style="text-align:center; margin-top:1rem;">Генератор ANSI‑блоков для Discord</h1>
  <div id="editor" contenteditable></div>
  <div class="toolbar">
    <button id="copy">Скопировать в Discord</button>
    <button id="clear">Очистить форматирование</button>
    <div style="font-weight:bold; margin-top:1rem;">Цвет текста</div>
    <div id="fg-palette" class="palette"></div>
    <div style="font-weight:bold;">Цвет фона</div>
    <div id="bg-palette" class="palette"></div>
    <div style="font-weight:bold; margin-top:.5rem;">Стили</div>
    <button id="bold">B</button>
    <button id="underline">U</button>
  </div>
  <div id="toast">Скопировано!</div>
<script>
  const ESC = '\u001b';
  const colors = ['gray','red','green','yellow','blue','magenta','cyan','white'];
  const fgCodes = [30,31,32,33,34,35,36,37];
  const bgCodes = fgCodes.map(c => c + 10);

  function wrap(type, value) {
    const sel = window.getSelection(); if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    if (type === 'fg') { span.dataset.fg = value; span.style.color = colors[fgCodes.indexOf(value)]; }
    if (type === 'bg') { span.dataset.bg = value; span.style.backgroundColor = colors[bgCodes.indexOf(value)]; }
    if (type === 'bold') { span.dataset.bold = '1'; span.style.fontWeight = 'bold'; }
    if (type === 'underline') { span.dataset.underline = '4'; span.style.textDecoration = 'underline'; }
    span.appendChild(range.extractContents());
    range.insertNode(span);
    sel.removeAllRanges();
  }

  // Build palettes
  const fgContainer = document.getElementById('fg-palette');
  const bgContainer = document.getElementById('bg-palette');
  fgCodes.forEach((code, i) => {
    const btn = document.createElement('button'); btn.style.background = colors[i]; btn.onclick = () => wrap('fg', code); fgContainer.appendChild(btn);
  });
  bgCodes.forEach((code, i) => {
    const btn = document.createElement('button'); btn.style.background = colors[i]; btn.onclick = () => wrap('bg', code); bgContainer.appendChild(btn);
  });
  document.getElementById('bold').onclick = () => wrap('bold');
  document.getElementById('underline').onclick = () => wrap('underline');
  document.getElementById('clear').onclick = () => { const ed = document.getElementById('editor'); ed.innerText = ed.innerText; };

  function generateANSI(root) {
    let out = '';
    const paragraphs = [];
    let current = [];
    root.childNodes.forEach(node => {
      if (node.nodeType === 1 && node.tagName === 'BR') {
        paragraphs.push(current);
        current = [];
      } else {
        current.push(node);
      }
    });
    paragraphs.push(current);

    paragraphs.forEach(nodes => {
      const items = [];
      function recurse(node, format) {
        const newFormat = Object.assign({}, format);
        if (node.nodeType === 1 && node.tagName === 'SPAN') {
          if (node.dataset.bold) newFormat.bold = true;
          if (node.dataset.underline) newFormat.underline = true;
          if (node.dataset.fg) newFormat.fg = node.dataset.fg;
          if (node.dataset.bg) newFormat.bg = node.dataset.bg;
        }
        if (node.nodeType === 3) {
          for (let i = 0; i < node.textContent.length; i++) {
            items.push({ char: node.textContent[i], format: newFormat });
          }
        } else if (node.nodeType === 1) {
          if (node.tagName === 'BR') {
            items.push({ char: '\n', format: {} });
          } else {
            Array.from(node.childNodes).forEach(child => recurse(child, newFormat));
          }
        }
      }
      nodes.forEach(n => recurse(n, {}));

      const hasColor = items.some(i => i.format.fg != null || i.format.bg != null);
      if (hasColor) {
        out += '```ansi\n';
        let prev = { bold: false, underline: false, fg: null, bg: null };
        items.forEach(item => {
          const fmt = item.format;
          const ch = item.char;
          if (ch !== ' ' && ch !== '\n' && (
              fmt.bold !== prev.bold ||
              fmt.underline !== prev.underline ||
              fmt.fg !== prev.fg ||
              fmt.bg !== prev.bg
            )) {
            const codes = [];
            if (fmt.bold) codes.push('1');
            if (fmt.underline) codes.push('4');
            if (fmt.fg) codes.push(fmt.fg);
            if (fmt.bg) codes.push(fmt.bg);
            out += ESC + '[' + (codes.length ? codes.join(';') : '0') + 'm';
            prev = Object.assign({}, fmt);
          }
          out += ch;
        });
        out += ESC + '[0m\n```\n';
      } else {
        let line = '';
        items.forEach(i => {
          if (i.format.bold && i.char.trim() !== '') {
            line += '**' + i.char + '**';
          } else {
            line += i.char;
          }
        });
        out += line + '\n';
      }
    });
    return out;
  }

  document.getElementById('copy').onclick = () => {
    const text = generateANSI(document.getElementById('editor'));
    navigator.clipboard.writeText(text).then(() => {
      const t = document.getElementById('toast'); t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 1500);
    });
  };
</script>
</body>
</html>
