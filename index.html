<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Генератор ANSI‑блоков для Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white">
  <div class="flex h-screen">
    <!-- Редактор -->
    <div class="flex-1 p-8 overflow-auto">
      <h1 class="text-2xl mb-4">Генератор ANSI‑блоков для Discord</h1>
      <div id="editor"
           contenteditable="true"
           class="w-full h-[80vh] bg-gray-800 p-4 rounded border border-gray-700 whitespace-pre-wrap overflow-auto">
        <!-- Начните писать здесь… -->
      </div>
    </div>

    <!-- Панель управления -->
    <div class="fixed top-24 right-4 w-64 bg-gray-800 p-4 rounded border border-gray-700 shadow-lg">
      <button id="copy"
              class="w-full bg-green-600 text-white py-2 rounded mb-2">
        Скопировать в Discord
      </button>
      <button id="clear"
              class="w-full bg-red-600 text-white py-2 rounded mb-4">
        Очистить форматирование
      </button>

      <!-- FG‑палитра -->
      <div class="mb-2 font-semibold">Цвет текста</div>
      <div id="fg-palette" class="grid grid-cols-4 gap-1 mb-4">
        <button data-fg="30" class="w-8 h-8 bg-gray-500 rounded border"></button>
        <button data-fg="31" class="w-8 h-8 bg-red-600 rounded"></button>
        <button data-fg="32" class="w-8 h-8 bg-green-600 rounded"></button>
        <button data-fg="33" class="w-8 h-8 bg-yellow-400 rounded"></button>
        <button data-fg="34" class="w-8 h-8 bg-blue-600 rounded"></button>
        <button data-fg="35" class="w-8 h-8 bg-pink-600 rounded"></button>
        <button data-fg="36" class="w-8 h-8 bg-cyan-400 rounded"></button>
        <button data-fg="37" class="w-8 h-8 bg-white rounded border"></button>
      </div>

      <!-- BG‑палитра -->
      <div class="mb-2 font-semibold">Цвет фона</div>
      <div id="bg-palette" class="grid grid-cols-4 gap-1 mb-4">
        <button data-bg="40" class="w-8 h-8 bg-[#23272A] rounded text-white"></button>
        <button data-bg="41" class="w-8 h-8 bg-[#FF8C00] rounded text-white"></button>
        <button data-bg="42" class="w-8 h-8 bg-[#5D8AA8] rounded text-white"></button>
        <button data-bg="43" class="w-8 h-8 bg-[#20B2AA] rounded text-white"></button>
        <button data-bg="44" class="w-8 h-8 bg-[#708090] rounded text-white"></button>
        <button data-bg="45" class="w-8 h-8 bg-[#4B0082] rounded text-white"></button>
        <button data-bg="46" class="w-8 h-8 bg-[#D3D3D3] rounded text-black"></button>
        <button data-bg="47" class="w-8 h-8 bg-[#FFFFFF] rounded text-black border"></button>
      </div>

      <!-- Стили -->
      <div class="mb-2 font-semibold">Стили</div>
      <div class="flex gap-2">
        <button id="bold"
                class="flex-1 border border-gray-600 rounded py-1 font-bold">
          B
        </button>
        <button id="underline"
                class="flex-1 border border-gray-600 rounded py-1 underline">
          U
        </button>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast"
         class="fixed bottom-4 right-4 bg-green-500 text-white py-2 px-4 rounded opacity-0 transition-opacity">
      Скопировано!
    </div>
  </div>

  <script>
    // Оборачивает выделение в <span>, даёт его колбэку, затем вставляет обратно
    function applyToSelection(fn) {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const fragment = range.extractContents();
      const wrapper = document.createElement('span');
      // Начальные значения, если ещё нет
      wrapper.dataset.bold = wrapper.dataset.bold || '';
      wrapper.dataset.underline = wrapper.dataset.underline || '';
      wrapper.dataset.fg = wrapper.dataset.fg || '';
      wrapper.dataset.bg = wrapper.dataset.bg || '';
      // Кладём в обёртку
      wrapper.appendChild(fragment);
      // Даем пользователю изменить dataset
      fn(wrapper);
      // Вставляем обратно
      range.insertNode(wrapper);
    }

    // Очищает только выделенный участок от <span>…</span>
    function clearFormatting() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const fragment = range.extractContents();

      function unwrap(node) {
        if (node.nodeType === 1 && node.tagName === 'SPAN') {
          const frag = document.createDocumentFragment();
          node.childNodes.forEach(c => frag.appendChild(unwrap(c)));
          return frag;
        }
        if (node.childNodes) {
          const copy = node.cloneNode(false);
          node.childNodes.forEach(c => copy.appendChild(unwrap(c)));
          return copy;
        }
        return node.cloneNode();
      }

      const clean = document.createDocumentFragment();
      fragment.childNodes.forEach(c => clean.appendChild(unwrap(c)));
      range.insertNode(clean);
    }

    // Привязка кнопок
    document.getElementById('clear').onclick = clearFormatting;

    document.getElementById('fg-palette').onclick = e => {
      const btn = e.target.closest('button[data-fg]');
      if (!btn) return;
      const code = btn.dataset.fg;
      applyToSelection(span => {
        span.dataset.fg = code;
      });
    };

    document.getElementById('bg-palette').onclick = e => {
      const btn = e.target.closest('button[data-bg]');
      if (!btn) return;
      const code = btn.dataset.bg;
      applyToSelection(span => {
        span.dataset.bg = code;
      });
    };

    document.getElementById('bold').onclick = () => {
      applyToSelection(span => {
        span.dataset.bold = span.dataset.bold === 'true' ? '' : 'true';
      });
    };

    document.getElementById('underline').onclick = () => {
      applyToSelection(span => {
        span.dataset.underline = span.dataset.underline === 'true' ? '' : 'true';
      });
    };

    // Toast
    function showToast() {
      const t = document.getElementById('toast');
      t.classList.add('opacity-100');
      setTimeout(() => t.classList.remove('opacity-100'), 1200);
    }

    // Сборка ANSI‑текста
    function generateANSI() {
      const editor = document.getElementById('editor');
      let out = '';

      // Получаем «абзацы» — либо DIVы внутри, либо текстовые узлы
      const paras = [];
      editor.childNodes.forEach(n => {
        if (n.nodeType === 1 && (n.tagName === 'DIV' || n.tagName === 'P')) {
          paras.push(n);
        } else if (n.nodeType === 3 && n.textContent.trim() !== '') {
          paras.push(n);
        }
      });

      paras.forEach(p => {
        // Собираем массив {char, fmt}
        const items = [];
        function traverse(node, fmt) {
          if (node.nodeType === 3) {
            for (let ch of node.textContent) {
              items.push({ char: ch, fmt: { ...fmt } });
            }
          } else if (node.nodeType === 1 && node.tagName === 'SPAN') {
            const f2 = { ...fmt };
            if (node.dataset.bold === 'true') f2.bold = true;
            if (node.dataset.underline === 'true') f2.underline = true;
            if (node.dataset.fg) f2.fg = node.dataset.fg;
            if (node.dataset.bg) f2.bg = node.dataset.bg;
            node.childNodes.forEach(c => traverse(c, f2));
          } else {
            node.childNodes.forEach(c => traverse(c, fmt));
          }
        }

        // Начальный формат
        traverse(p, { bold: false, underline: false, fg: '0', bg: '0' });

        const hasColor = items.some(it => it.fmt.fg !== '0' || it.fmt.bg !== '0');
        if (!hasColor) {
          // Markdown‑bold абзац
          const raw = p.nodeType === 3 ? p.textContent : p.textContent;
          const needBold = items.some(it => it.fmt.bold);
          out += needBold ? `**${raw}**\n` : `${raw}\n`;
        } else {
          // ANSI‑блок
          out += '```ansi\n';
          let prev = { bold: false, underline: false, fg: '0', bg: '0' };
          for (let it of items) {
            if (it.char === '\n') continue;
            const f = it.fmt;
            const changed =
              f.bold  !== prev.bold  ||
              f.underline !== prev.underline ||
              f.fg    !== prev.fg    ||
              f.bg    !== prev.bg;

            if (changed && it.char !== ' ') {
              // Формируем всегда четыре кода
              const codes = [
                f.bold ? 1 : 0,
                f.underline ? 4 : 0,
                Number(f.fg),
                Number(f.bg)
              ];
              out += `\u001b[${codes.join(';')}m`;
              prev = { ...f };
            }
            out += it.char;
          }
          // Общий сброс
          out += '\u001b[0;0;0;0m\n```\n';
        }
      });

      return out;
    }

    // Копировать
    document.getElementById('copy').onclick = () => {
      const txt = generateANSI();
      navigator.clipboard.writeText(txt).then(showToast);
    };
  </script>
</body>
</html>
