<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Генератор ANSI‑блоков для Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-white">
  <div class="flex h-screen">
    <!-- Редактор -->
    <div class="flex-1 p-8 overflow-auto">
      <h1 class="text-2xl mb-4">Генератор ANSI‑блоков для Discord</h1>
      <div id="editor"
           contenteditable="true"
           class="w-full h-[80vh] bg-gray-800 p-4 rounded border border-gray-700 whitespace-pre-wrap overflow-auto">
        <!-- пусто -->
      </div>
    </div>

    <!-- Панель управления -->
    <div class="fixed top-24 right-4 w-64 bg-gray-800 p-4 rounded border border-gray-700 shadow-lg">
      <button id="copy"
              class="w-full bg-green-600 text-white py-2 rounded mb-2">
        Скопировать в Discord
      </button>
      <button id="clear"
              class="w-full bg-red-600 text-white py-2 rounded mb-4">
        Очистить форматирование
      </button>

      <!-- FG‑палитра -->
      <div class="mb-2 font-semibold">Цвет текста</div>
      <div id="fg-palette" class="grid grid-cols-4 gap-1 mb-4">
        <button data-fg="30" class="w-8 h-8 bg-gray-500 rounded border"></button>
        <button data-fg="31" class="w-8 h-8 bg-red-600 rounded"></button>
        <button data-fg="32" class="w-8 h-8 bg-green-600 rounded"></button>
        <button data-fg="33" class="w-8 h-8 bg-yellow-400 rounded"></button>
        <button data-fg="34" class="w-8 h-8 bg-blue-600 rounded"></button>
        <button data-fg="35" class="w-8 h-8 bg-pink-600 rounded"></button>
        <button data-fg="36" class="w-8 h-8 bg-cyan-400 rounded"></button>
        <button data-fg="37" class="w-8 h-8 bg-white rounded border"></button>
      </div>

      <!-- BG‑палитра -->
      <div class="mb-2 font-semibold">Цвет фона</div>
      <div id="bg-palette" class="grid grid-cols-4 gap-1 mb-4">
        <button data-bg="40" class="w-8 h-8 bg-[#23272A] rounded text-white"></button>
        <button data-bg="41" class="w-8 h-8 bg-[#FF8C00] rounded text-white"></button>
        <button data-bg="42" class="w-8 h-8 bg-[#5D8AA8] rounded text-white"></button>
        <button data-bg="43" class="w-8 h-8 bg-[#20B2AA] rounded text-white"></button>
        <button data-bg="44" class="w-8 h-8 bg-[#708090] rounded text-white"></button>
        <button data-bg="45" class="w-8 h-8 bg-[#4B0082] rounded text-white"></button>
        <button data-bg="46" class="w-8 h-8 bg-[#D3D3D3] rounded text-black"></button>
        <button data-bg="47" class="w-8 h-8 bg-[#FFFFFF] rounded text-black border"></button>
      </div>

      <!-- Стили -->
      <div class="mb-2 font-semibold">Стили</div>
      <div class="flex gap-2">
        <button id="bold"
                class="flex-1 border border-gray-600 rounded py-1 font-bold">
          B
        </button>
        <button id="underline"
                class="flex-1 border border-gray-600 rounded py-1 underline">
          U
        </button>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast"
         class="fixed bottom-4 right-4 bg-green-500 text-white py-2 px-4 rounded opacity-0 transition-opacity">
      Скопировано!
    </div>
  </div>

  <script>
    console.log('⚙️ Скрипт загружен');

    // Убираем автогенерацию пустых абзацев
    document.addEventListener('DOMContentLoaded', () => {
      const editor = document.getElementById('editor');
      editor.innerHTML = '';
      console.log('editor очищён от пустышек');
    });

    // Оборачивает выделение в <span> и выполняет fn(span)
    function applyToSelection(fn, name) {
      const sel = window.getSelection();
      console.log(`applyToSelection (${name})`, 'count=', sel.rangeCount, 'text=', sel.toString(), 'collapsed=', sel.isCollapsed);
      if (!sel.rangeCount || sel.isCollapsed) {
        console.log(`  → пропускаем, нет выделения`);
        return;
      }
      const range = sel.getRangeAt(0);
      const fragment = range.extractContents();
      const span = document.createElement('span');
      span.dataset.bold = span.dataset.bold || '';
      span.dataset.underline = span.dataset.underline || '';
      span.dataset.fg = span.dataset.fg || '';
      span.dataset.bg = span.dataset.bg || '';
      span.appendChild(fragment);
      console.log('  before fn dataset:', span.dataset);
      fn(span);
      console.log('  after fn dataset:', span.dataset);
      range.insertNode(span);
      console.log('  → формат применён');
    }

    // Очищает форматирование только в выделенном фрагменте
    function clearFormatting() {
      const sel = window.getSelection();
      console.log('clearFormatting', 'count=', sel.rangeCount, 'text=', sel.toString());
      if (!sel.rangeCount || sel.isCollapsed) {
        console.log('  → пропускаем, нет выделения');
        return;
      }
      const range = sel.getRangeAt(0);
      const frag = range.extractContents();

      function unwrap(node) {
        if (node.nodeType === 1 && node.tagName === 'SPAN') {
          const df = document.createDocumentFragment();
          node.childNodes.forEach(c => df.appendChild(unwrap(c)));
          return df;
        } else if (node.childNodes) {
          const cpy = node.cloneNode(false);
          node.childNodes.forEach(c => cpy.appendChild(unwrap(c)));
          return cpy;
        }
        return node.cloneNode();
      }

      const clean = document.createDocumentFragment();
      frag.childNodes.forEach(c => clean.appendChild(unwrap(c)));
      range.insertNode(clean);
      console.log('  → форматирование убрано');
    }

    // Toast
    function showToast() {
      console.log('showToast');
      const t = document.getElementById('toast');
      t.classList.add('opacity-100');
      setTimeout(() => t.classList.remove('opacity-100'), 1200);
    }

    // ANSI‑генератор
    function generateANSI() {
      console.log('generateANSI');
      const editor = document.getElementById('editor');
      let out = '';

      // Собираем «абзацы»
      const paras = [];
      editor.childNodes.forEach(n => {
        // берём только непустые или стилизованные узлы
        if (
          (n.nodeType === 1 && (n.tagName==='DIV' || n.tagName==='P') && n.textContent.trim()!=='') ||
          (n.nodeType === 3 && n.textContent.trim()!=='')
        ) paras.push(n);
      });
      console.log('  параграфов найдено:', paras.length);

      paras.forEach((p, pi) => {
        console.log(`  параграф[${pi}] текст:`, p.textContent);
        // собираем символы + формат
        const items = [];
        function trav(node, fmt) {
          if (node.nodeType === 3) {
            for (let ch of node.textContent) {
              items.push({ char: ch, fmt: { ...fmt } });
            }
          } else if (node.nodeType === 1 && node.tagName==='SPAN') {
            const f2 = { ...fmt };
            if (node.dataset.bold==='true')      f2.bold = true;
            if (node.dataset.underline==='true') f2.underline = true;
            if (node.dataset.fg)                f2.fg = node.dataset.fg;
            if (node.dataset.bg)                f2.bg = node.dataset.bg;
            node.childNodes.forEach(c=>trav(c,f2));
          } else {
            node.childNodes.forEach(c=>trav(c,fmt));
          }
        }
        trav(p, { bold:false, underline:false, fg:'0', bg:'0' });
        console.log(`    символов:`, items.length);

        // решаем, ANSI или Markdown
        const hasColor = items.some(it=>it.fmt.fg!=='0'||it.fmt.bg!
